import logging
from contextlib import asynccontextmanager
from typing import Annotated

import uvicorn
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.responses import HTMLResponse
from githubkit import GitHub
from pydantic import ValidationError
from sqlalchemy import Engine
from sqlmodel import Session, create_engine

from ghutils.bot.core.env import GHUtilsEnv
from ghutils.bot.db.engine import check_db_connection
from ghutils.bot.db.models import UserGitHubTokens, UserLogin

logger = logging.getLogger(__name__)

engine: Engine


def get_session():
    with Session(engine, expire_on_commit=False) as session:
        yield session


@asynccontextmanager
async def lifespan(app: FastAPI):
    global engine
    engine = create_engine(GHUtilsEnv.get().db_url)
    check_db_connection(engine)
    yield


app = FastAPI(
    lifespan=lifespan,
)


@app.get("/login")
async def get_login(
    code: str,
    state: str,
    session: Annotated[Session, Depends(get_session)],
    env: Annotated[GHUtilsEnv, Depends(GHUtilsEnv.get)],
):
    # parse state to UserLogin
    try:
        login = UserLogin.model_validate_json(state)
    except (ValueError, ValidationError) as e:
        logger.debug(f"Failed to parse login state: {e}")
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Failed to parse login state")

    # make sure the login id matches the one generated by the login command
    match db_login := session.get(UserLogin, login.user_id):
        case UserLogin(login_id=login.login_id):
            session.delete(db_login)
        case UserLogin() | None:
            logger.debug(f"Invalid login state: {db_login}")
            raise HTTPException(status.HTTP_400_BAD_REQUEST, "Invalid login state")

    # get the access/refresh tokens from GitHub
    github = GitHub(env.gh.get_oauth_app_auth())
    auth = await github.auth.as_web_user(
        code=code,
        redirect_uri=env.gh.redirect_uri,
    ).async_exchange_token(github)  # pyright: ignore[reportUnknownMemberType]

    # insert the tokens into the database
    match session.get(UserGitHubTokens, login.user_id):
        case UserGitHubTokens() as user_tokens:
            user_tokens.refresh(auth)
        case None:
            user_tokens = UserGitHubTokens.from_auth(login.user_id, auth)
    session.add(user_tokens)

    # commit the delete and insert
    session.commit()

    return HTMLResponse("Yay!")  # FIXME: make a real success page or something


if __name__ == "__main__":
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=GHUtilsEnv.get().api_port,
    )
